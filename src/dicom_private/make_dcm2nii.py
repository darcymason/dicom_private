# Copyright (c) 2025 Darcy Mason and contributors. All rights reserved.
# See LICENSE file for details
"""Generate a private dict file from dcm2nii private tags file 
(https://github.com/InsightSoftwareConsortium/DCMTK/blob/master/dcmdata/data/private.dic)

"""
from collections import defaultdict, namedtuple
import csv
from datetime import datetime
import re
from typing import Generator
from urllib.request import urlopen

from dicom_private.core import write_dict

RE_ENTRY = re.compile(
    r"\s*?'(.*?)'\s*?'(.*?)'\s*?'(.*?)'\s*?'(.*?)'"
    r"(?:\s*?%\s*?(.*))?"
)

URL = (
    "https://raw.githubusercontent.com/xiangruili/dicm2nii/"
    "refs/heads/master/dicm_dict.m"
)
FIELDS = "vendor group elem vr name comment".split()
Entry = namedtuple("Entry", FIELDS)
DICT_FILENAME = "dcm2nii.py"
PY_NAME = "dcm2nii_dict"
DICT_DOCSTRING = f"""DICOM private dictionary auto-generated by make_dcm2nii.py.

Data generated {datetime.now():%Y-%m-%d %H:%M} from
{URL}

NOTE: The outer dictionary key for dcm2nii is the **Vendor** (GE, Siemens, etc.)
(not Private Creator name as for most dicts), while the inner
dictionary key is a map of DICOM tag to (VR, VM, name, is_retired).
"""


def dcm2nii_reader(reader) -> Generator[tuple[str, str, str, str, str, str], None, None]:
    """Return parsed lines, each a named tuple (Entry)"""


    # "tag creator vr name vm tag_type"
    seeking = True

    rdr = iter(reader)
    next(rdr)  # ignore first line defining function

    for line in rdr:
        if seeking and "strncmpi(vendor," in line:
            seeking = False
            vendor = line.split(",")[1].strip().replace("'", "")
            continue
        line = line.strip()
        if line.startswith("}"):
            seeking = True
            continue
        if not (match := RE_ENTRY.match(line)):
            continue
        group, elem, vr, name, comment = match.groups()
        if int(group, 16) % 2 == 0:
            continue  # only do private (group odd)
        group = group.upper()
        elem = elem.upper()
        if elem.startswith("10"):
            elem = "xx" + elem[2:]
        yield Entry(vendor, group, elem, vr, name, comment)


def private_dictionaries(reader) -> dict[str, dict[str, tuple[str, str, str, str]]]:
    """Reformat original data into kind needed for pydicom-style dict
    Params:
    reader: file-like
        Object that iterates one original dict line at a time
    """
    dicts = defaultdict(dict)
    for entry in dcm2nii_reader(reader):
        tag = f"{entry.group}{entry.elem}"
        dicts[entry.vendor][tag] = (entry.vr, "", entry.name)

    return dicts

def make_keyword(s):
    return s.replace(" ", "").replace("_", "")

def match_other_sources(priv_dict, source_dicts, source_names):
    """Since dcm2nii doesn't have full private creator,
    attempt to match based on tag and keyword/name to see
    if dcm2nii has some entries that the others do not.

    Match is done with spaces removed and both lower case to avoid
    minor differences showing as significant

    Return dict of {tag: entry} that doesn not appear to be in other source dicts
    """
    matches = defaultdict(list)
    no_matches = {}
    for vendor, tag_dict in priv_dict.items():
        for tag, vals in tag_dict.items():
            tag_match=False
            for source_dict, source_name in zip(source_dicts, source_names):
                for creator, source_tag_dict in source_dict.items():
                    if tag in source_tag_dict:
                        source_keyword = make_keyword(source_tag_dict[tag][2])
                        if make_keyword(vals[2]).lower() == source_keyword.lower():
                            matches[tag].append((source_name, creator))
                            tag_match = True
            if not tag_match:
                no_matches[tag] = (vendor, vals)
    return no_matches


if __name__ == "__main__":

    # with urlopen(URL) as response:
    #     reader = response.read().decode("utf-8").splitlines()
        # priv_dict = private_dictionaries(reader)
    
    # for entry in dcm2nii_reader(s.splitlines()):
    #     print(entry)

    lines = open(r"c:\temp\dicom-private-dicts\dcm2nii\dicm_dict.m", "r", encoding="utf-8").read().splitlines()
    # with urlopen(URL) as response:
    #     lines = response.read().decode("utf-8").splitlines()

    priv_dict = private_dictionaries(lines)
    write_dict(priv_dict, DICT_FILENAME, docstring=DICT_DOCSTRING, py_name=PY_NAME)

    from dicom_private.dicts.dcmtk import dcmtk_dict
    from dicom_private.dicts.dicom3tools import dicom3tools_dict
    from dicom_private.dicts.gdcm import gdcm_dict
    from dicom_private.dicts.tcia import tcia_dict
    source_dicts = (dcmtk_dict, dicom3tools_dict, gdcm_dict, tcia_dict)
    source_names = ("dcmtk", "dicom3tools", "gdcm", "tcia")

    with open(r"c:\temp\dicom-private-dicts\dcm2nii unique.txt", "w", encoding="utf-8") as f:
        f.write(str(match_other_sources(priv_dict, source_dicts, source_names)))
