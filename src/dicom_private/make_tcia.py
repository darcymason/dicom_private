# tcia_dict.py
"""Parse the TCIA private tags file 
(https://wiki.cancerimagingarchive.net/download/attachments/3539047/TCIAPrivateTagKB-02-01-2024-formatted.csv?version=2&modificationDate=1707174689263&api=v2)
described at
(https://wiki.cancerimagingarchive.net/display/Public/Submission+and+De-identification+Overview#:~:text=Private%20Tags%20%E2%80%93)
"""
from collections import defaultdict, namedtuple
import csv
from datetime import datetime
from pathlib import Path
from typing import Generator
from urllib.request import urlopen
import re
import tempfile

from dicom_private.core import write_dict

TCIA_URL = (
    "https://wiki.cancerimagingarchive.net/download/attachments/3539047/"
    "TCIAPrivateTagKB-02-01-2024-formatted.csv"
    "?version=2&modificationDate=1707174689263&api=v2"
)
TCIA_FIELDS = "creator tag vr name disposition".split()
TciaTuple = namedtuple("TciaTuple", TCIA_FIELDS)
DICT_FILENAME = "tcia.py"
PY_NAME = "tcia_dict"
DICT_DOCSTRING = f"""DICOM private dictionary auto-generated by make_tcia.py.

Data generated {datetime.now():%Y-%m-%d %H:%M} from
{TCIA_URL}

The outer dictionary key is the Private Creator name ("owner"), while the inner
dictionary key is a map of DICOM tag to (VR, VM, name, is_retired).
"""

RE_ELEMENT_SIG_TAG_PATTERN = re.compile(
    r"\(([0-9A-Fa-f]+)"  # Initial 4-digit hex group
    r"(?:,(.*?))?,"  # Optional middle creator (can be ",," empty too)
    r"([0-9A-Fa-f]+)\)"  # Final 2 or 4-digit hex tag element
)


def parse_elem_sig_tag(elem: str) -> tuple[str, str]:
    match = RE_ELEMENT_SIG_TAG_PATTERN.match(elem)
    if not match:
        raise ValueError("Unable to parse elem sign pattern")
    tag1, *creator, tag2 = match.groups()
    tag1 = tag1.upper()
    tag2 = tag2.upper()
    creator = creator[0]
    if len(tag2) == 2:
        tag2 = f"xx{tag2}"
    return (creator, f"{tag1}{tag2}")


def tcia_reader(line_reader) -> Generator[list[tuple[str | None, str, str, str, str]], None, None]:
    """Return parsed lines, each a named tuple (TciaTuple)

    Lines with a blank `creator` are not returned
    """

    csv_fieldnames = "tag_complex names vr disposition".split()
    csv_reader = csv.DictReader(line_reader, fieldnames = csv_fieldnames, delimiter=",")
    for row in csv_reader:
        # Each row can have multiple elem patterns separated by "[<#>]"
        # and corresponding name field separated by ":"
        # e.g. "(0009[,creator],00)[<0>](0023,creator,15)[<1>](0023,creator,16)",Unknown:Unknown:Unknown,IS,d
        elems = re.split(r"\[<\d+>\]", row["tag_complex"])
        names = row["names"].split(":")
        assert len(names) == len(elems)
        for elem, name in zip(elems, names):
            creator, tag = parse_elem_sig_tag(elem)
            yield TciaTuple(creator, tag, row["vr"], name, row["disposition"])


def private_dictionaries(line_reader) -> dict[str, dict[str, tuple[str, str, str, str]]]:
    """Reformat original data into kind needed for pydicom-style dict

    Params:
    reader: file-like
        Object that iterates one original data line at a time
    """
    dicts = defaultdict(dict)
    for tcia_tup in tcia_reader(line_reader):
        # skip DICOM (even group) tags
        if int(tcia_tup.tag[:4], 16) % 2 == 0:
            continue
        if not tcia_tup.creator:
            continue
        # TCIA often repeats things with different VR, so append that if already exists
        if tcia_tup.creator in dicts and tcia_tup.tag in dicts[tcia_tup.creator]:
            vr, _, name = dicts[tcia_tup.creator][tcia_tup.tag]
            # XXX maybe this could leave out some different names?
            if tcia_tup.vr in vr.split(",") and tcia_tup.name == name:
                continue
            vr += f",{tcia_tup.vr}" if vr else tcia_tup.vr
            name += f";{tcia_tup.name}" if name else tcia_tup.name
        else:
            vr = tcia_tup.vr
            name = tcia_tup.name
        # pydicom-style dicts have val (VR, VM, name, [is_retired added in write_dict]
        dicts[tcia_tup.creator][tcia_tup.tag] = vr, "", tcia_tup.name

    return dicts


if __name__ == "__main__":
    with urlopen(TCIA_URL) as response:
        line_reader = (
            line.replace('""', "")
            for line in response.read().decode("utf-8").splitlines()[1:]
            if line.strip() != ""
        )
        priv_dict = private_dictionaries(line_reader)
    
    write_dict(priv_dict, DICT_FILENAME, docstring=DICT_DOCSTRING, py_name=PY_NAME)
