# Copyright (c) 2025 Darcy Mason and contributors. All rights reserved.
# See LICENSE file for details
"""Generate a private dict file fomr dicom3tools private tags file 
(https://github.com/InsightSoftwareConsortium/DATA/blob/master/dcmdata/data/private.dic)

"""
from collections import defaultdict, namedtuple
import csv
from datetime import datetime
from pathlib import Path
import re
from typing import Generator
from urllib.request import urlopen

from dicom_private.core import write_dict, HERE, DATA_PATH


DATA_FILES_PATH = DATA_PATH / "dicom3tools_elmdict"

# (0003,0001) VERS="EL1"	VR="OW"   VM="1"	Owner="ELSCINT1"
# 	Keyword="OffsetListStructure"			Name="Offset List Structure"
DATA_FIELDS = "tag vers vr vm owner keyword name".split()
DataLine = namedtuple("DataLine", DATA_FIELDS)
DICT_FILENAME = "dicom3tools.py"
PY_NAME = "dicom3tools_dict"
DICT_DOCSTRING = f"""DICOM private dictionary auto-generated by make_dicom3tools.py.

Data generated {datetime.now():%Y-%m-%d %H:%M} from
{DATA_FILES_PATH.relative_to(HERE)}

The outer dictionary key is the Private Creator name ("owner"), while the inner
dictionary key is a map of DICOM tag to (VR, VM, name, is_retired).
"""

RE_LINE_PATTERN = re.compile(
    r"(?a)"  # ascii
    r"(\(.*?(?:,).*?\))"  # tag s=as "(gggg,eeee)"
    r'\s*VERS="(.*?)"\s*VR="(.*?)"\s*VM="(.*?)"'
    r'\s*Owner="(.*?)"\s*K?Keyword="(.*?)"\s*Name="(.*?)"?'  # one line missing closing quote, one extra K
)

def multi_file_reader(path):
    filenames = Path(path).glob("*.tpl")
    for filename in filenames:
        if filename.name in ("dicom3.tpl", "diconde.tpl", "dicos.tpl"):
            print(f"Skipping file {filename.name} with no Owner data")
            continue
        with open(filename, "r", encoding="utf-8") as f:
            for line in f:
                line = line.strip()
                if not line or line.startswith("#"):
                    continue
                match = RE_LINE_PATTERN.match(line)
                assert match, f"Unable to parse line '{line}' in {filename.name}"
                yield DataLine(*match.groups())


def private_dictionaries(path) -> dict[str, dict[str, tuple[str, str, str, str]]]:
    """Reformat original data into kind needed for pydicom-style dict
    Params:
    reader: file-like
        Object that iterates one original dict line at a time
    """
    dicts = defaultdict(dict)
    for line in multi_file_reader(path):
        tag = re.sub(r"\((.*?),(.*?)\)", r"\1\2", line.tag)
        if tag[4:6] == "00":
            tag = f"{tag[:4]}xx{tag[6:]}"   # XX Assume it is a mask!
        dicts[line.owner][tag] = (line.vr, line.vm, line.keyword)

    return dicts


if __name__ == "__main__":
    from itertools import islice
    limit = None  # set None unless testing
    # for line in islice(multi_file_reader(DATA_FILES_PATH), limit):
    #     print(line)

    priv_dict = private_dictionaries(DATA_FILES_PATH)
    # print(priv_dict)
    write_dict(priv_dict, DICT_FILENAME, docstring=DICT_DOCSTRING, py_name=PY_NAME)
